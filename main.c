#include "config.h"
#include <avr/io.h>
#include <avr/pgmspace.h>
#include <avr/interrupt.h>
#include <util/delay.h>
#include "uart.h"
#include <string.h>
#include <avr/eeprom.h>
#include "irdeto_core.h"

#define delay 20

/* Standard responses */
const uint8_t _atr[19] PROGMEM = {
//0x3B, 0x9F, 0x21, 0x0E, 0x49, 0x52, 0x44, 0x45, 0x54, 0x4F, 0x20, 0x41, 0x43, 0x53, 0x20, 0x56, 0x36, 0x2E, 0x30}; // ACS 6.0
0x3B, 0x9F, 0x21, 0x0E, 0x49, 0x52, 0x44, 0x45, 0x54, 0x4F, 0x20, 0x41, 0x43, 0x53, 0x20, 0x56, 0x31, 0x2E, 0x32}; // ACS 1.2
//0x3B, 0x9F, 0x21, 0x0E, 0x49, 0x52, 0x44, 0x45, 0x54, 0x4F, 0x20, 0x41, 0x43, 0x53, 0x03, 0x84, 0x95, 0xFF, 0x80}; // 0384
//0x3B, 0x9F, 0x21, 0x0E, 0x49, 0x52, 0x44, 0x45, 0x54, 0x4F, 0x20, 0x41, 0x43, 0x53, 0x03, 0x83, 0x95, 0x00, 0x80}; // 0383

const uint8_t _ASN[28] PROGMEM = { // 0x00030000
    0x01, 0x02, 0x00, 0x00, 0x00, 0x03, 0x00, 0x14,
    0x34, 0x30, 0x31, 0x30, 0x35, 0x39, 0x38, 0x37,
    0x30, 0x38, 0x1E, 0xB3, 0x1D, 0x73, 0x01, 0x00,
    0x11, 0x11, 0x08, 0x08
};

const uint8_t _HS[24] PROGMEM = { // 0x01000000
    0x01, 0x02, 0x00, 0x00, 0x01, 0x03, 0x00, 0x10,
    0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x02, 0x00, 0x11, 0x22, 0x33, 0x18
};

const uint8_t _COCO[24] PROGMEM = { // 0x02030000
    0x01, 0x02, 0x00, 0x00, 0x02, 0x03, 0x00, 0x10,
    0x03, 0x83, 0x00, 0x06, 0x01, 0x06, 0x02, 0x06,
    0x03, 0x06, 0x04, 0x00, 0x00, 0x47, 0x45, 0x52
};

const uint8_t _CAID[24] PROGMEM = { // 0x02000000
    0x01, 0x02, 0x00, 0x00, 0x02, 0x00, 0x00, 0x10,
    0x03, 0x83, 0x00, 0x06, 0x01, 0x06, 0x02, 0x06,
    0x03, 0x06, 0x04, 0x00, 0x00, 0x47, 0x45, 0x52
};

const uint8_t _ans0b[31] PROGMEM = { // 0x0b000000
    0x01, 0x02, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x17,
    0x47, 0x45, 0x52, 0x00, 0x90, 0x00, 0x46, 0x00,
    0x32, 0x00, 0x00, 0x00, 0x00, 0x4E, 0x65, 0x6F,
    0x37, 0x35, 0x33, 0x30, 0x00, 0x00, 0x00
};

const uint8_t _pro00[32] PROGMEM = { // 0x03030000
    0x01, 0x02, 0x00, 0x00, 0x03, 0x03, 0x00, 0x18,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

const uint8_t _pro10[32] PROGMEM = { // 0x03030100
    0x01, 0x02, 0x00, 0x00, 0x03, 0x03, 0x01, 0x18,
    0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0xFF
};

const uint8_t _err[8] PROGMEM = { //else
    0x01, 0x02, 0x6B, 0x00, 0x0E, 0x00, 0x00, 0x00
};

const uint8_t _sigw[8] PROGMEM = {
0x01, 0x05, 0x9E, 0x00, 0x00, 0x00, 0x02, 0x00
};

const uint8_t _camk[8] PROGMEM = { // 0x09030040
    0x01, 0x02, 0x55, 0x00, 0x09, 0x03, 0x00, 0x00
};

const uint8_t _r05[14] PROGMEM = {
   0x01, 0x05, 0x9D, 0x00, 0x38, 0x00, 0x02, 0x16,
   0xFF, 0xFF, 0x01, 0xFF, 0xFF, 0xFF
};

const uint8_t _keyupdate_ok[11] PROGMEM = {
   0x01, 0x01, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x03,
   0x00, 0x40, 0x01
};

const uint8_t _keysig_wrong[8] PROGMEM = {
   0x01, 0x01, 0x7C, 0x00, 0x00, 0x00, 0x00, 0x00
};

const uint8_t _keyprov_wrong[8] PROGMEM = {
   0x01, 0x01, 0x71, 0x00, 0x00, 0x00, 0x00, 0x00
};

uint8_t _pmk00[8] EEMEM = {
    0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88
};

uint8_t _pmk10[8] EEMEM = {
    0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88
};

uint8_t _pid00[3] EEMEM = {
    0x11, 0x22, 0x33
};

uint8_t _pid10[3] EEMEM = {
    0x11, 0x22, 0x33
};

uint8_t _date00[2] EEMEM = {0x00,0x00};
uint8_t _date10[2] EEMEM = {0x00,0x00};

uint8_t _key10[8][8] EEMEM = {
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, //02 03
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, //04
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, //06
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, //08
    {0x15, 0x31, 0xD8, 0x29, 0x9B, 0x41, 0xBF, 0x0B}, //0A
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, //0C
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, //0E
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}  //10
};

uint8_t _key00[8][8] EEMEM = {
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, //02 03
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, //04
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, //06
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, //08
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, //0A
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, //0C
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, //0E
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}  //10
};


/* I/O buffers */
static uint8_t _ib[80];
static uint8_t _ob[40];
static uint8_t _camkey[8];
//static uint8_t _date[2];

void _response(const uint8_t *_data,uint8_t _len,uint8_t _xor){
int a;
_delay_ms(1);
enable_tx();
uint8_t c;
        for(a = 0;a < _len;a++){
            c =  pgm_read_byte(&_data[a]);
            _xor ^= c;
            io_write(0x100 | c);
            _delay_us(delay);
        }
        io_write(0x100 | _xor);
enable_rx();
}

void _response_buff(uint8_t *_data,uint8_t _len){
int a;
_delay_ms(1);
enable_tx();
uint8_t xor = 0x3f;
        for(a = 0;a < _len;a++){
            io_write( 0x100 | _data[a]);
            xor ^= _data[a];
            _delay_us(delay);
          }
        io_write(0x100 | xor);
enable_rx();
}


void _command(uint32_t in){
    uint8_t i;
    switch(in){
        case 0x00030000:
            _response(_ASN,28,0x3F);break;
        case 0x01000000:
        case 0x01030000:
            _response(_HS,24,0x3F);break;
        case 0x02030000:
            _response(_COCO,24,0x3f);break;
        case 0x02000000:
            _response(_CAID,24,0x3f);break;
        case 0x0b000000:
            _response(_ans0b,31,0x3F);break;
        case 0x03030000:
            for(i=0;i<32;i++)_ob[i] = pgm_read_byte(&_pro00[i]);
            eeprom_read_block(&_ob[9],_pid00,3);
            eeprom_read_block(&_ob[18],_date00,2);
            _response_buff(_ob,32);break;
            //_response(_pro00,32,0x3f);break;
        case 0x03030100:
            for(i=0;i<32;i++)_ob[i] = pgm_read_byte(&_pro10[i]);
            eeprom_read_block(&_ob[9],_pid10,3);
            eeprom_read_block(&_ob[18],_date10,2);
            _response_buff(_ob,32);break;
            //_response(_pro10,32,0x3f);break;
        case 0x09030040:
            for(i=7;i<71;i++)_ib[i] = io_read() & 0xff;
            _response(_camk,8,0x3f);
            memcpy(&_camkey[0],&_ib[6],8);break;
        default:
            _response(_err,8,0x3f);break;
    }
}

void _parse01(void){
    uint8_t _zpk[10];
    uint8_t _sig[8];
    uint8_t chk[5];
    uint8_t ki = 0;

    (_ib[6] == 0x0A) || (_ib[6] == 0x0B) ? eeprom_read_block(_zpk,_pmk10,8) : eeprom_read_block(_zpk,_pmk00,8);
    _zpk[8] = _zpk[0] ^ _ib[14];
    _zpk[9] = _zpk[1] ^ _ib[15];

    decrypt(_ib,_zpk,127,8,19);

    memcpy(&chk[0],&_ib[35],5);
    sign(_sig,_ib,_zpk,5);

    switch(_ib[18]){
        case 0x02:
        case 0x03:
            ki = 0;break;
        case 0x04:
        case 0x05:
            ki = 1;break;
        case 0x06:
        case 0x07:
            ki = 2;break;
        case 0x08:
        case 0x09:
            ki = 3;break;
        case 0x0a:
        case 0x0b:
            ki = 4;break;
        case 0x0c:
        case 0x0d:
            ki = 5;break;
        case 0x0e:
        case 0x0f:
            ki = 6;break;
        case 0x10:
        case 0x11:
            ki = 7;break;
    };

    if((_ib[7] == eeprom_read_byte(&_pid00[0]) && (_ib[8] == eeprom_read_byte(&_pid00[1]))) ||
        ((_ib[7] == eeprom_read_byte(&_pid10[0])) && (_ib[8] == eeprom_read_byte(&_pid10[1])))){
    if(memcmp(_sig,chk,5) == 0){
        (_ib[6] == 0x0A) || (_ib[6] == 0x0B) ? eeprom_update_block(&_ib[19],&_key10[ki][0],8) : eeprom_update_block(&_ib[19],&_key00[ki][0],8);
        (_ib[6] == 0x0A) || (_ib[6] == 0x0B) ? eeprom_update_block(&_ib[14],_date10,2) : eeprom_update_block(&_ib[14],_date00,2);
        _response(_keyupdate_ok,11,0x3F);
    } else {
        _response(_keysig_wrong,8,0x3F);
    }

        } else {
            _response(_keyprov_wrong,8,0x3F);
        }

}


void _parse05(void){

    uint8_t i;
    uint8_t _sig[8];
    uint8_t chk[5];
    uint8_t _ccr[16];
    uint8_t _zpk[10];
    uint8_t ki = 0;

    switch(_ib[9]){
        case 0x02:
        case 0x03:
            ki = 0;break;
        case 0x04:
        case 0x05:
            ki = 1;break;
        case 0x06:
        case 0x07:
            ki = 2;break;
        case 0x08:
        case 0x09:
            ki = 3;break;
        case 0x0a:
        case 0x0b:
            ki = 4;break;
        case 0x0c:
        case 0x0d:
            ki = 5;break;
        case 0x0e:
        case 0x0f:
            ki = 6;break;
        case 0x10:
        case 0x11:
            ki = 7;break;
    };

    _ib[8] == 0 ? eeprom_read_block(_zpk,_key00[ki],8) : eeprom_read_block(_zpk,_key10[ki],8);

    _zpk[8] = _zpk[0] ^ _ib[14];
    _zpk[9] = _zpk[1] ^ _ib[15];

    decrypt(_ib,_zpk,127,8,20);
    decrypt(_ib,_zpk,127,8,28);
    memcpy(&chk[0],&_ib[36],5);
    sign(_sig,_ib,_zpk,5);
    /* CAMCRYPT */
    memcpy(&_ccr[0],&_ib[20],16);
    camcrypt(_camkey,_ccr);

    /* BUILD ANSWER */
    for(i=0;i<14;i++){
        _ob[i] = pgm_read_byte(&_r05[i]);
    }

    memcpy(&_ob[14],&_ccr[0],16);
    memcpy(&_ob[8],&_ib[6],2); //CHID
    _ob[11] = _ib[19];
    _ob[5] = _ob[11] & 1;

    if(memcmp(_sig,chk,5)== 0) {
            _response_buff(_ob,30);
            _ib[8] == 0 ? eeprom_update_block(&_ib[14],_date00,2):eeprom_update_block(&_ib[14],_date10,2);
    } else {
        _response(_sigw,8,0x3f);
    }
}


int main(void)
{
	uint8_t i;
    uint32_t cmd = 0;
	io_init();

	/* Enable interrupts */
	sei();
    _delay_ms(10);
    _response(_atr,19,0x3B);

	while(1){
        while(_ib[1] != 0x02 && _ib[1] != 0x01 && _ib[1] != 0x05){
            _ib[0] = 0;
            while(_ib[0] != 0x01){
                _ib[0] = io_read() & 0xff;
            }
            _ib[1] = io_read() & 0xff;
        }


        switch(_ib[1]){

            case 0x01:
                for(i=2;i<6;i++) _ib[i] = io_read() & 0xff;
                for(i=6;i < _ib[5]+6;i++) _ib[i] = io_read() & 0xff;
                _parse01();break;

            case 0x02:
                for(i = 0; i<4;i++){
                    cmd <<= 8;
                    cmd |= io_read() & 0xff;
                }
                _ib[6] = io_read() & 0xff;
                _command(cmd);break;
            case 0x05:
                for(i=2;i<6;i++) _ib[i] = io_read() & 0xff;
                for(i=6;i < _ib[5]+6;i++) _ib[i] = io_read() & 0xff;
                _parse05();break;
            default:
                break;
        }

        memset(_ib,0,80);
	}
	return(0);
}
